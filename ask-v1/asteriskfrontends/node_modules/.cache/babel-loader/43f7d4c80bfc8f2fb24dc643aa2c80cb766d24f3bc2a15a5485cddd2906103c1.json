{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar Logger = require('./Logger');\nvar Grammar = require('./Grammar');\nvar SIPMessage = require('./SIPMessage');\nvar logger = new Logger('Parser');\n/**\n * Parse SIP Message\n */\n\nexports.parseMessage = function (data, ua) {\n  var message;\n  var bodyStart;\n  var headerEnd = data.indexOf('\\r\\n');\n  if (headerEnd === -1) {\n    logger.warn('parseMessage() | no CRLF found, not a SIP message');\n    return;\n  } // Parse first line. Check if it is a Request or a Reply.\n\n  var firstLine = data.substring(0, headerEnd);\n  var parsed = Grammar.parse(firstLine, 'Request_Response');\n  if (parsed === -1) {\n    logger.warn(\"parseMessage() | error parsing first line of SIP message: \\\"\".concat(firstLine, \"\\\"\"));\n    return;\n  } else if (!parsed.status_code) {\n    message = new SIPMessage.IncomingRequest(ua);\n    message.method = parsed.method;\n    message.ruri = parsed.uri;\n  } else {\n    message = new SIPMessage.IncomingResponse();\n    message.status_code = parsed.status_code;\n    message.reason_phrase = parsed.reason_phrase;\n  }\n  message.data = data;\n  var headerStart = headerEnd + 2;\n  /* Loop over every line in data. Detect the end of each header and parse\n  * it or simply add to the headers collection.\n  */\n\n  while (true) {\n    headerEnd = getHeader(data, headerStart); // The SIP message has normally finished.\n\n    if (headerEnd === -2) {\n      bodyStart = headerStart + 2;\n      break;\n    } // Data.indexOf returned -1 due to a malformed message.\n    else if (headerEnd === -1) {\n      logger.warn('parseMessage() | malformed message');\n      return;\n    }\n    parsed = parseHeader(message, data, headerStart, headerEnd);\n    if (parsed !== true) {\n      logger.warn('parseMessage() |', parsed.error);\n      return;\n    }\n    headerStart = headerEnd + 2;\n  }\n  /* RFC3261 18.3.\n   * If there are additional bytes in the transport packet\n   * beyond the end of the body, they MUST be discarded.\n   */\n\n  if (message.hasHeader('content-length')) {\n    var contentLength = message.getHeader('content-length');\n    message.body = data.substr(bodyStart, contentLength);\n  } else {\n    message.body = data.substring(bodyStart);\n  }\n  return message;\n};\n/**\n * Extract and parse every header of a SIP message.\n */\n\nfunction getHeader(data, headerStart) {\n  // 'start' position of the header.\n  var start = headerStart; // 'end' position of the header.\n\n  var end = 0; // 'partial end' position of the header.\n\n  var partialEnd = 0; // End of message.\n\n  if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n    return -2;\n  }\n  while (end === 0) {\n    // Partial End of Header.\n    partialEnd = data.indexOf('\\r\\n', start); // 'indexOf' returns -1 if the value to be found never occurs.\n\n    if (partialEnd === -1) {\n      return partialEnd;\n    }\n    if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n      // Not the end of the message. Continue from the next position.\n      start = partialEnd + 2;\n    } else {\n      end = partialEnd;\n    }\n  }\n  return end;\n}\nfunction parseHeader(message, data, headerStart, headerEnd) {\n  var parsed;\n  var hcolonIndex = data.indexOf(':', headerStart);\n  var headerName = data.substring(headerStart, hcolonIndex).trim();\n  var headerValue = data.substring(hcolonIndex + 1, headerEnd).trim(); // If header-field is well-known, parse it.\n\n  switch (headerName.toLowerCase()) {\n    case 'via':\n    case 'v':\n      message.addHeader('via', headerValue);\n      if (message.getHeaders('via').length === 1) {\n        parsed = message.parseHeader('Via');\n        if (parsed) {\n          message.via = parsed;\n          message.via_branch = parsed.branch;\n        }\n      } else {\n        parsed = 0;\n      }\n      break;\n    case 'from':\n    case 'f':\n      message.setHeader('from', headerValue);\n      parsed = message.parseHeader('from');\n      if (parsed) {\n        message.from = parsed;\n        message.from_tag = parsed.getParam('tag');\n      }\n      break;\n    case 'to':\n    case 't':\n      message.setHeader('to', headerValue);\n      parsed = message.parseHeader('to');\n      if (parsed) {\n        message.to = parsed;\n        message.to_tag = parsed.getParam('tag');\n      }\n      break;\n    case 'record-route':\n      parsed = Grammar.parse(headerValue, 'Record_Route');\n      if (parsed === -1) {\n        parsed = undefined;\n      } else {\n        var _iterator = _createForOfIteratorHelper(parsed),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var header = _step.value;\n            message.addHeader('record-route', headerValue.substring(header.possition, header.offset));\n            message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      break;\n    case 'call-id':\n    case 'i':\n      message.setHeader('call-id', headerValue);\n      parsed = message.parseHeader('call-id');\n      if (parsed) {\n        message.call_id = headerValue;\n      }\n      break;\n    case 'contact':\n    case 'm':\n      parsed = Grammar.parse(headerValue, 'Contact');\n      if (parsed === -1) {\n        parsed = undefined;\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(parsed),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _header = _step2.value;\n            message.addHeader('contact', headerValue.substring(_header.possition, _header.offset));\n            message.headers.Contact[message.getHeaders('contact').length - 1].parsed = _header.parsed;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      break;\n    case 'content-length':\n    case 'l':\n      message.setHeader('content-length', headerValue);\n      parsed = message.parseHeader('content-length');\n      break;\n    case 'content-type':\n    case 'c':\n      message.setHeader('content-type', headerValue);\n      parsed = message.parseHeader('content-type');\n      break;\n    case 'cseq':\n      message.setHeader('cseq', headerValue);\n      parsed = message.parseHeader('cseq');\n      if (parsed) {\n        message.cseq = parsed.value;\n      }\n      if (message instanceof SIPMessage.IncomingResponse) {\n        message.method = parsed.method;\n      }\n      break;\n    case 'max-forwards':\n      message.setHeader('max-forwards', headerValue);\n      parsed = message.parseHeader('max-forwards');\n      break;\n    case 'www-authenticate':\n      message.setHeader('www-authenticate', headerValue);\n      parsed = message.parseHeader('www-authenticate');\n      break;\n    case 'proxy-authenticate':\n      message.setHeader('proxy-authenticate', headerValue);\n      parsed = message.parseHeader('proxy-authenticate');\n      break;\n    case 'session-expires':\n    case 'x':\n      message.setHeader('session-expires', headerValue);\n      parsed = message.parseHeader('session-expires');\n      if (parsed) {\n        message.session_expires = parsed.expires;\n        message.session_expires_refresher = parsed.refresher;\n      }\n      break;\n    case 'refer-to':\n    case 'r':\n      message.setHeader('refer-to', headerValue);\n      parsed = message.parseHeader('refer-to');\n      if (parsed) {\n        message.refer_to = parsed;\n      }\n      break;\n    case 'replaces':\n      message.setHeader('replaces', headerValue);\n      parsed = message.parseHeader('replaces');\n      if (parsed) {\n        message.replaces = parsed;\n      }\n      break;\n    case 'event':\n    case 'o':\n      message.setHeader('event', headerValue);\n      parsed = message.parseHeader('event');\n      if (parsed) {\n        message.event = parsed;\n      }\n      break;\n    default:\n      // Do not parse this header.\n      message.addHeader(headerName, headerValue);\n      parsed = 0;\n  }\n  if (parsed === undefined) {\n    return {\n      error: \"error parsing header \\\"\".concat(headerName, \"\\\"\")\n    };\n  } else {\n    return true;\n  }\n}","map":{"version":3,"names":["_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","Logger","require","Grammar","SIPMessage","logger","exports","parseMessage","data","ua","message","bodyStart","headerEnd","indexOf","warn","firstLine","substring","parsed","parse","concat","status_code","IncomingRequest","method","ruri","uri","IncomingResponse","reason_phrase","headerStart","getHeader","parseHeader","error","hasHeader","contentLength","body","substr","start","end","partialEnd","match","charAt","hcolonIndex","headerName","trim","headerValue","toLowerCase","addHeader","getHeaders","via","via_branch","branch","setHeader","from_tag","getParam","to","to_tag","undefined","_iterator","_step","header","possition","offset","headers","call_id","_iterator2","_step2","_header","Contact","cseq","session_expires","expires","session_expires_refresher","refresher","refer_to","replaces","event"],"sources":["/etc/asterisk/webrtc-phone/node_modules/jssip/lib-es5/Parser.js"],"sourcesContent":["\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar Logger = require('./Logger');\n\nvar Grammar = require('./Grammar');\n\nvar SIPMessage = require('./SIPMessage');\n\nvar logger = new Logger('Parser');\n/**\n * Parse SIP Message\n */\n\nexports.parseMessage = function (data, ua) {\n  var message;\n  var bodyStart;\n  var headerEnd = data.indexOf('\\r\\n');\n\n  if (headerEnd === -1) {\n    logger.warn('parseMessage() | no CRLF found, not a SIP message');\n    return;\n  } // Parse first line. Check if it is a Request or a Reply.\n\n\n  var firstLine = data.substring(0, headerEnd);\n  var parsed = Grammar.parse(firstLine, 'Request_Response');\n\n  if (parsed === -1) {\n    logger.warn(\"parseMessage() | error parsing first line of SIP message: \\\"\".concat(firstLine, \"\\\"\"));\n    return;\n  } else if (!parsed.status_code) {\n    message = new SIPMessage.IncomingRequest(ua);\n    message.method = parsed.method;\n    message.ruri = parsed.uri;\n  } else {\n    message = new SIPMessage.IncomingResponse();\n    message.status_code = parsed.status_code;\n    message.reason_phrase = parsed.reason_phrase;\n  }\n\n  message.data = data;\n  var headerStart = headerEnd + 2;\n  /* Loop over every line in data. Detect the end of each header and parse\n  * it or simply add to the headers collection.\n  */\n\n  while (true) {\n    headerEnd = getHeader(data, headerStart); // The SIP message has normally finished.\n\n    if (headerEnd === -2) {\n      bodyStart = headerStart + 2;\n      break;\n    } // Data.indexOf returned -1 due to a malformed message.\n    else if (headerEnd === -1) {\n        logger.warn('parseMessage() | malformed message');\n        return;\n      }\n\n    parsed = parseHeader(message, data, headerStart, headerEnd);\n\n    if (parsed !== true) {\n      logger.warn('parseMessage() |', parsed.error);\n      return;\n    }\n\n    headerStart = headerEnd + 2;\n  }\n  /* RFC3261 18.3.\n   * If there are additional bytes in the transport packet\n   * beyond the end of the body, they MUST be discarded.\n   */\n\n\n  if (message.hasHeader('content-length')) {\n    var contentLength = message.getHeader('content-length');\n    message.body = data.substr(bodyStart, contentLength);\n  } else {\n    message.body = data.substring(bodyStart);\n  }\n\n  return message;\n};\n/**\n * Extract and parse every header of a SIP message.\n */\n\n\nfunction getHeader(data, headerStart) {\n  // 'start' position of the header.\n  var start = headerStart; // 'end' position of the header.\n\n  var end = 0; // 'partial end' position of the header.\n\n  var partialEnd = 0; // End of message.\n\n  if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n    return -2;\n  }\n\n  while (end === 0) {\n    // Partial End of Header.\n    partialEnd = data.indexOf('\\r\\n', start); // 'indexOf' returns -1 if the value to be found never occurs.\n\n    if (partialEnd === -1) {\n      return partialEnd;\n    }\n\n    if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n      // Not the end of the message. Continue from the next position.\n      start = partialEnd + 2;\n    } else {\n      end = partialEnd;\n    }\n  }\n\n  return end;\n}\n\nfunction parseHeader(message, data, headerStart, headerEnd) {\n  var parsed;\n  var hcolonIndex = data.indexOf(':', headerStart);\n  var headerName = data.substring(headerStart, hcolonIndex).trim();\n  var headerValue = data.substring(hcolonIndex + 1, headerEnd).trim(); // If header-field is well-known, parse it.\n\n  switch (headerName.toLowerCase()) {\n    case 'via':\n    case 'v':\n      message.addHeader('via', headerValue);\n\n      if (message.getHeaders('via').length === 1) {\n        parsed = message.parseHeader('Via');\n\n        if (parsed) {\n          message.via = parsed;\n          message.via_branch = parsed.branch;\n        }\n      } else {\n        parsed = 0;\n      }\n\n      break;\n\n    case 'from':\n    case 'f':\n      message.setHeader('from', headerValue);\n      parsed = message.parseHeader('from');\n\n      if (parsed) {\n        message.from = parsed;\n        message.from_tag = parsed.getParam('tag');\n      }\n\n      break;\n\n    case 'to':\n    case 't':\n      message.setHeader('to', headerValue);\n      parsed = message.parseHeader('to');\n\n      if (parsed) {\n        message.to = parsed;\n        message.to_tag = parsed.getParam('tag');\n      }\n\n      break;\n\n    case 'record-route':\n      parsed = Grammar.parse(headerValue, 'Record_Route');\n\n      if (parsed === -1) {\n        parsed = undefined;\n      } else {\n        var _iterator = _createForOfIteratorHelper(parsed),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var header = _step.value;\n            message.addHeader('record-route', headerValue.substring(header.possition, header.offset));\n            message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      break;\n\n    case 'call-id':\n    case 'i':\n      message.setHeader('call-id', headerValue);\n      parsed = message.parseHeader('call-id');\n\n      if (parsed) {\n        message.call_id = headerValue;\n      }\n\n      break;\n\n    case 'contact':\n    case 'm':\n      parsed = Grammar.parse(headerValue, 'Contact');\n\n      if (parsed === -1) {\n        parsed = undefined;\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(parsed),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _header = _step2.value;\n            message.addHeader('contact', headerValue.substring(_header.possition, _header.offset));\n            message.headers.Contact[message.getHeaders('contact').length - 1].parsed = _header.parsed;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      break;\n\n    case 'content-length':\n    case 'l':\n      message.setHeader('content-length', headerValue);\n      parsed = message.parseHeader('content-length');\n      break;\n\n    case 'content-type':\n    case 'c':\n      message.setHeader('content-type', headerValue);\n      parsed = message.parseHeader('content-type');\n      break;\n\n    case 'cseq':\n      message.setHeader('cseq', headerValue);\n      parsed = message.parseHeader('cseq');\n\n      if (parsed) {\n        message.cseq = parsed.value;\n      }\n\n      if (message instanceof SIPMessage.IncomingResponse) {\n        message.method = parsed.method;\n      }\n\n      break;\n\n    case 'max-forwards':\n      message.setHeader('max-forwards', headerValue);\n      parsed = message.parseHeader('max-forwards');\n      break;\n\n    case 'www-authenticate':\n      message.setHeader('www-authenticate', headerValue);\n      parsed = message.parseHeader('www-authenticate');\n      break;\n\n    case 'proxy-authenticate':\n      message.setHeader('proxy-authenticate', headerValue);\n      parsed = message.parseHeader('proxy-authenticate');\n      break;\n\n    case 'session-expires':\n    case 'x':\n      message.setHeader('session-expires', headerValue);\n      parsed = message.parseHeader('session-expires');\n\n      if (parsed) {\n        message.session_expires = parsed.expires;\n        message.session_expires_refresher = parsed.refresher;\n      }\n\n      break;\n\n    case 'refer-to':\n    case 'r':\n      message.setHeader('refer-to', headerValue);\n      parsed = message.parseHeader('refer-to');\n\n      if (parsed) {\n        message.refer_to = parsed;\n      }\n\n      break;\n\n    case 'replaces':\n      message.setHeader('replaces', headerValue);\n      parsed = message.parseHeader('replaces');\n\n      if (parsed) {\n        message.replaces = parsed;\n      }\n\n      break;\n\n    case 'event':\n    case 'o':\n      message.setHeader('event', headerValue);\n      parsed = message.parseHeader('event');\n\n      if (parsed) {\n        message.event = parsed;\n      }\n\n      break;\n\n    default:\n      // Do not parse this header.\n      message.addHeader(headerName, headerValue);\n      parsed = 0;\n  }\n\n  if (parsed === undefined) {\n    return {\n      error: \"error parsing header \\\"\".concat(headerName, \"\\\"\")\n    };\n  } else {\n    return true;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}